use std::fmt::Debug;

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Token {
	// Esil Opcodes
	EInterrupt,
	ECmp,
	ELt,
	EGt,
	EEq,
	EIf,
	ELsl,
	ELsr,
	ERor,
	ERol,
	EAnd,
	EOr,
	ENop,
	ENeg,
	EMul,
	EXor,
	EAdd,
	ESub,
	EDiv,
	EMod,
	EPoke(u8),
	EPeek(u8),
	EDump,
	EPop,
	ETodo,
	EGoto,
	EBreak,
	EClear,
	EDup,
	ETrap,
	// Esil Internal Vars
	IZero(u8),
	ICarry(u8),
	IParity(u8),
	IOverflow(u8),
	ISign(u8),
	IBorrow(u8),
	IRegSize(u8),
	IAddress(u8),
	// Esil Operands
	EOpConst(u64),
	EOpReg(usize),
	// Invalid
	EInvalid,
	// Parser Instructions.
	PCopy(usize),
	PPop(usize),
	PSync,
}

pub trait Tokenize {
	type Token: Clone + Copy + Debug;
	fn tokenize<T: AsRef<str>>(esil: T) -> Vec<Self::Token>;
}

pub struct Tokenizer;

impl Tokenize for Tokenizer {
	type Token = Token;
	fn tokenize<T: AsRef<str>>(esil: T) -> Vec<Self::Token> {
		let mut tokens = Vec::new();
		for t in esil.as_ref().split(",").into_iter() {
			tokens.extend(
				&match t {
					"$" => vec![Token::EInterrupt],
					"==" => vec![Token::ECmp],
					"<" => vec![Token::ELt],
					">" => vec![Token::EGt],
					"<=" => vec![Token::PCopy(2), Token::ELt, Token::PPop(2),
					             Token::EEq, Token::PSync, Token::EOr],
					">=" => vec![Token::PCopy(2), Token::EGt, Token::PPop(2),
					             Token::EEq, Token::PSync, Token::EOr],
					"?{" => vec![Token::EIf],
					"<<" => vec![Token::ELsl],
					"<<=" => vec![Token::PCopy(2), Token::ELsl, Token::PPop(1),
					              Token::EPop, Token::EEq],
					">>" => vec![Token::ELsr],
					">>=" => vec![Token::PCopy(2), Token::ELsr, Token::PPop(1),
					              Token::EPop, Token::EEq],
					">>>" => vec![Token::ERor],
					"<<<" => vec![Token::ERol],
					"&" => vec![Token::EAnd],
					"&=" => vec![Token::PCopy(2), Token::EAnd, Token::PPop(1),
					             Token::EPop, Token::EEq],
					"}" => vec![Token::ENop],
					"|" => vec![Token::EOr],
					"|=" => vec![Token::PCopy(2), Token::EOr, Token::PPop(1),
					             Token::EPop, Token::EEq],
					"!" => vec![Token::ENeg],
					"!=" => vec![Token::PCopy(1), Token::ENeg, Token::EEq],
					"=" => vec![Token::EEq],
					"*" => vec![Token::EMul],
					"*=" => vec![Token::PCopy(2), Token::EMul, Token::PPop(1),
					             Token::EPop, Token::EEq],
					"^" => vec![Token::EXor],
					"^=" => vec![Token::PCopy(2), Token::EXor, Token::PPop(1),
					             Token::EPop, Token::EEq],
					"+" => vec![Token::EAdd],
					"+=" => vec![Token::PCopy(2), Token::EAdd, Token::PPop(1),
					             Token::EPop, Token::EEq],
					"++" => vec![Token::PPop(1), Token::EOpConst(1), Token::EAdd],
					"++=" => vec![Token::PCopy(1), Token::EOpConst(1), Token::EAdd,
					              Token::PPop(1), Token::EEq],
					"-" => vec![Token::ESub],
					"-=" => vec![Token::PCopy(2), Token::ESub, Token::PPop(1),
					             Token::EPop, Token::EEq],
					"--" => vec![Token::PPop(1), Token::EOpConst(1), Token::ESub],
					"--=" => vec![Token::PCopy(1), Token::EOpConst(1), Token::ESub,
					              Token::PPop(1), Token::EEq],
					"/" => vec![Token::EDiv],
					"/=" => vec![Token::PCopy(2), Token::EDiv, Token::PPop(1),
					             Token::EPop, Token::EEq],
					"%" => vec![Token::EMod],
					"%=" => vec![Token::PCopy(2), Token::EMod, Token::PPop(1),
					             Token::EPop, Token::EEq],
					"=[]" => vec![Token::EPoke(64)],
					"=[1]" => vec![Token::EPoke(8)],
					"=[2]" => vec![Token::EPoke(16)],
					"=[4]" => vec![Token::EPoke(32)],
					"=[8]" => vec![Token::EPoke(64)],
					"|=[]" => vec![Token::PCopy(1), Token::EPeek(64), Token::EOr,
					               Token::PPop(1), Token::EPop, Token::EPoke(64)],
					"|=[1]" => vec![Token::PCopy(1), Token::EPeek(8), Token::EOr,
					               Token::PPop(1), Token::EPop, Token::EPoke(8)],
					"|=[2]" => vec![Token::PCopy(1), Token::EPeek(16), Token::EOr,
					               Token::PPop(1), Token::EPop, Token::EPoke(16)],
					"|=[4]" => vec![Token::PCopy(1), Token::EPeek(32), Token::EOr,
					               Token::PPop(1), Token::EPop, Token::EPoke(32)],
					"|=[8]" => vec![Token::PCopy(1), Token::EPeek(64), Token::EOr,
					               Token::PPop(1), Token::EPop, Token::EPoke(64)],
					"^=[]" => vec![Token::PCopy(1), Token::EPeek(64), Token::EXor,
					               Token::PPop(1), Token::EPop, Token::EPoke(64)],
					"^=[1]" => vec![Token::PCopy(1), Token::EPeek(8), Token::EXor,
					               Token::PPop(1), Token::EPop, Token::EPoke(8)],
					"^=[2]" => vec![Token::PCopy(1), Token::EPeek(16), Token::EXor,
					               Token::PPop(1), Token::EPop, Token::EPoke(16)],
					"^=[4]" => vec![Token::PCopy(1), Token::EPeek(32), Token::EXor,
					               Token::PPop(1), Token::EPop, Token::EPoke(32)],
					"^=[8]" => vec![Token::PCopy(1), Token::EPeek(64), Token::EXor,
					               Token::PPop(1), Token::EPop, Token::EPoke(64)],
					"&=[]" => vec![Token::PCopy(1), Token::EPeek(64), Token::EAnd,
					               Token::PPop(1), Token::EPop, Token::EPoke(64)],
					"&=[1]" => vec![Token::PCopy(1), Token::EPeek(8), Token::EAnd,
					               Token::PPop(1), Token::EPop, Token::EPoke(8)],
					"&=[2]" => vec![Token::PCopy(1), Token::EPeek(16), Token::EAnd,
					               Token::PPop(1), Token::EPop, Token::EPoke(16)],
					"&=[4]" => vec![Token::PCopy(1), Token::EPeek(32), Token::EAnd,
					               Token::PPop(1), Token::EPop, Token::EPoke(32)],
					"&=[8]" => vec![Token::PCopy(1), Token::EPeek(64), Token::EAnd,
					               Token::PPop(1), Token::EPop, Token::EPoke(64)],
					"+=[]" => vec![Token::PCopy(1), Token::EPeek(64), Token::EAdd,
					               Token::PPop(1), Token::EPop, Token::EPoke(64)],
					"+=[1]" => vec![Token::PCopy(1), Token::EPeek(8), Token::EAdd,
					               Token::PPop(1), Token::EPop, Token::EPoke(8)],
					"+=[2]" => vec![Token::PCopy(1), Token::EPeek(16), Token::EAdd,
					               Token::PPop(1), Token::EPop, Token::EPoke(16)],
					"+=[4]" => vec![Token::PCopy(1), Token::EPeek(32), Token::EAdd,
					               Token::PPop(1), Token::EPop, Token::EPoke(32)],
					"+=[8]" => vec![Token::PCopy(1), Token::EPeek(64), Token::EAdd,
					               Token::PPop(1), Token::EPop, Token::EPoke(64)],
					"-=[]" => vec![Token::PCopy(1), Token::EPeek(64), Token::ESub,
					               Token::PPop(1), Token::EPop, Token::EPoke(64)],
					"-=[1]" => vec![Token::PCopy(1), Token::EPeek(8), Token::ESub,
					               Token::PPop(1), Token::EPop, Token::EPoke(8)],
					"-=[2]" => vec![Token::PCopy(1), Token::EPeek(16), Token::ESub,
					               Token::PPop(1), Token::EPop, Token::EPoke(16)],
					"-=[4]" => vec![Token::PCopy(1), Token::EPeek(32), Token::ESub,
					               Token::PPop(1), Token::EPop, Token::EPoke(32)],
					"-=[8]" => vec![Token::PCopy(1), Token::EPeek(64), Token::ESub,
					               Token::PPop(1), Token::EPop, Token::EPoke(64)],
					"%=[]" => vec![Token::PCopy(1), Token::EPeek(64), Token::EMod,
					               Token::PPop(1), Token::EPop, Token::EPoke(64)],
					"%=[1]" => vec![Token::PCopy(1), Token::EPeek(8), Token::EMod,
					               Token::PPop(1), Token::EPop, Token::EPoke(8)],
					"%=[2]" => vec![Token::PCopy(1), Token::EPeek(16), Token::EMod,
					               Token::PPop(1), Token::EPop, Token::EPoke(16)],
					"%=[4]" => vec![Token::PCopy(1), Token::EPeek(32), Token::EMod,
					               Token::PPop(1), Token::EPop, Token::EPoke(32)],
					"%=[8]" => vec![Token::PCopy(1), Token::EPeek(64), Token::EMod,
					               Token::PPop(1), Token::EPop, Token::EPoke(64)],
					"/=[]" => vec![Token::PCopy(1), Token::EPeek(64), Token::EDiv,
					               Token::PPop(1), Token::EPop, Token::EPoke(64)],
					"/=[1]" => vec![Token::PCopy(1), Token::EPeek(8), Token::EDiv,
					               Token::PPop(1), Token::EPop, Token::EPoke(8)],
					"/=[2]" => vec![Token::PCopy(1), Token::EPeek(16), Token::EDiv,
					               Token::PPop(1), Token::EPop, Token::EPoke(16)],
					"/=[4]" => vec![Token::PCopy(1), Token::EPeek(32), Token::EDiv,
					               Token::PPop(1), Token::EPop, Token::EPoke(32)],
					"/=[8]" => vec![Token::PCopy(1), Token::EPeek(64), Token::EDiv,
					               Token::PPop(1), Token::EPop, Token::EPoke(64)],
					"*=[]" => vec![Token::PCopy(1), Token::EPeek(64), Token::EMul,
					               Token::PPop(1), Token::EPop, Token::EPoke(64)],
					"*=[1]" => vec![Token::PCopy(1), Token::EPeek(8), Token::EMul,
					               Token::PPop(1), Token::EPop, Token::EPoke(8)],
					"*=[2]" => vec![Token::PCopy(1), Token::EPeek(16), Token::EMul,
					               Token::PPop(1), Token::EPop, Token::EPoke(16)],
					"*=[4]" => vec![Token::PCopy(1), Token::EPeek(32), Token::EMul,
					               Token::PPop(1), Token::EPop, Token::EPoke(32)],
					"*=[8]" => vec![Token::PCopy(1), Token::EPeek(64), Token::EMul,
					               Token::PPop(1), Token::EPop, Token::EPoke(64)],
					"++=[]" => vec![Token::PCopy(1), Token::EPeek(64),
					               Token::EOpConst(1), Token::EAdd,
					               Token::PPop(1), Token::EPoke(64)],
					"++=[1]" => vec![Token::PCopy(1), Token::EPeek(8),
					               Token::EOpConst(1), Token::EAdd,
					               Token::PPop(1), Token::EPoke(8)],
					"++=[2]" => vec![Token::PCopy(1), Token::EPeek(16),
					               Token::EOpConst(1), Token::EAdd,
					               Token::PPop(1), Token::EPoke(16)],
					"++=[4]" => vec![Token::PCopy(1), Token::EPeek(32),
					               Token::EOpConst(1), Token::EAdd,
					               Token::PPop(1), Token::EPoke(32)],
					"++=[8]" => vec![Token::PCopy(1), Token::EPeek(64),
					               Token::EOpConst(1), Token::EAdd,
					               Token::PPop(1), Token::EPoke(64)],
					"--=[]" => vec![Token::EOpConst(1), Token::PPop(1),
					                 Token::PCopy(1), Token::EPeek(64),
									 Token::ESub, Token::PPop(1),
									 Token::EPoke(64)],
					"--=[1]" => vec![Token::EOpConst(1), Token::PPop(1),
					                 Token::PCopy(1), Token::EPeek(8),
									 Token::ESub, Token::PPop(1),
									 Token::EPoke(8)],
					"--=[2]" => vec![Token::EOpConst(1), Token::PPop(1),
					                 Token::PCopy(1), Token::EPeek(16),
									 Token::ESub, Token::PPop(1),
									 Token::EPoke(16)],
					"--=[4]" => vec![Token::EOpConst(1), Token::PPop(1),
					                 Token::PCopy(1), Token::EPeek(32),
									 Token::ESub, Token::PPop(1),
									 Token::EPoke(32)],
					"--=[8]" => vec![Token::EOpConst(1), Token::PPop(1),
					                 Token::PCopy(1), Token::EPeek(64),
									 Token::ESub, Token::PPop(1),
									 Token::EPoke(64)],
					"[]" => vec![Token::EPeek(64)],
					"[*]" => vec![Token::EPeek(64)],
					"=[*]" => vec![Token::EPoke(64)],
					"[1]" => vec![Token::EPeek(8)],
					"[2]" => vec![Token::EPeek(16)],
					"[4]" => vec![Token::EPeek(32)],
					"[8]" => vec![Token::EPeek(64)],
					"STACK" => vec![Token::EDump],
					"POP" => vec![Token::EPop],
					"TODO" => vec![Token::ETodo],
					"GOTO" => vec![Token::EGoto],
					"BREAK" => vec![Token::EBreak],
					"CLEAR" => vec![Token::EClear],
					"DUP" => vec![Token::EDup],
					"TRAP" => vec![Token::ETrap],
					_   => {
						// Handle Operands
						vec![Token::EInvalid]
					}
				});
		}
		tokens
	}
}

#[cfg(test)]
mod test {
	use super::*;

	#[test]
	fn esil_basic() {
		let op = vec![Token::EAdd];
		assert_eq!(op[0], Tokenizer::tokenize("+")[0]);
	}
}
